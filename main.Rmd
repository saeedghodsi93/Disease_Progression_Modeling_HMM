---
title: "Disease Progression Modeling using HMMs"
author: "Saeed Ghodsi"
header-includes:
   - \usepackage{bbm}
   - \usepackage{url}
   - \usepackage{booktabs}
   - \usepackage{amsfonts}
   - \usepackage{nicefrac}
   - \usepackage{microtype}
   - \usepackage{xcolor}
   - \usepackage{ae,aecompl}
   - \usepackage{color}
   - \usepackage{babel}
   - \usepackage{booktabs}
   - \usepackage{mathrsfs}
   - \usepackage{bbm}
   - \usepackage{xcolor}
   - \usepackage{amsmath}
   - \usepackage{amsthm}
   - \usepackage{mathtools}
   - \usepackage{amsfonts}
   - \usepackage{graphicx}
   - \usepackage{subfig}
   - \usepackage{setspace}
   - \usepackage{perpage}
   - \usepackage{comment}
   - \allowdisplaybreaks
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

# add the libraries
library(MASS)
library(reticulate)
library(xtable)
library(tidyverse)
library(tinytex)
library(ggplot2)
library(plotly) 
library(reshape2)
library(graphics)
library(AER)
library(expm)
library(FNN)
library(msm)

# add the R files
source("CTHMM/setup.R")
source("CTHMM/debugging.R")
source("CTHMM/set_parameters.R")
source("CTHMM/data_generation.R")
source("CTHMM/forward_backward.R")
source("CTHMM/end_conditioned_expectations.R")
source("CTHMM/e_step.R")
source("CTHMM/m_step.R")
source("CTHMM/em_algorithm.R")
source("CTHMM/cthmm.R")
source("CTHMM_Ext1/set_parameters.R")
source("CTHMM_Ext1/data_generation.R")
source("CTHMM_Ext1/forward_backward.R")
source("CTHMM_Ext1/end_conditioned_expectations.R")
source("CTHMM_Ext1/e_step.R")
source("CTHMM_Ext1/m_step.R")
source("CTHMM_Ext1/em_algorithm.R")
source("CTHMM_Ext1/cthmm_ext1.R")
source("DTHMM/set_parameters.R")
source("DTHMM/data_generation.R")
source("DTHMM/forward_backward.R")
source("DTHMM/gibbs_sampling.R")
source("DTHMM/e_step.R")
source("DTHMM/m_step.R")
source("DTHMM/em_algorithm.R")
source("DTHMM/dthmm.R")

# call the initial setup function
setup.func()

# add the Python files
source_python("CTHMM/visualization.py")
source_python("CTHMM_Ext1/visualization.py")
source_python("DTHMM/visualization.py")

# choose which model to run ("DTHMM", "CTHMM", "CTHMM_Ext1", or "None")
model.type <- "CTHMM_Ext1"

# set the operation modes
run.algorithm <- TRUE
debugging.mode <- TRUE
latex.table <- FALSE
   
```


Analyze the DTHMM model:

```{r, echo = TRUE, warning = FALSE}

# run the DT-HMM model
if (model.type == "DTHMM") {
   
   ret.dthmm <- dthmm.func(run.algorithm, debugging.mode, latex.table)
   I <- ret.dthmm$I
   J <- ret.dthmm$J
   L <- ret.dthmm$L
   N.vals <- ret.dthmm$N.vals
   M.vals <- ret.dthmm$M.vals
   H <- ret.dthmm$H
   z <- ret.dthmm$z
   y <- ret.dthmm$y
   u <- ret.dthmm$u
   pi <- ret.dthmm$pi
   Q <- ret.dthmm$Q
   mu <- ret.dthmm$mu
   eta <- ret.dthmm$eta
   pi.hat.vals <- ret.dthmm$pi.hat.vals
   Q.hat.vals <- ret.dthmm$Q.hat.vals
   mu.hat.vals <- ret.dthmm$mu.hat.vals
   eta.hat.vals <- ret.dthmm$eta.hat.vals
   total.time <- ret.dthmm$total.time
   
}

```


Analyze the CTHMM model:

```{r, echo = TRUE, warning = FALSE}

# run the CT-HMM model
if (model.type == "CTHMM") {

   ret.cthmm <- cthmm.func(run.algorithm, debugging.mode, latex.table)
   I <- ret.cthmm$I
   J <- ret.cthmm$J
   L <- ret.cthmm$L
   N.vals <- ret.cthmm$N.vals
   H <- ret.cthmm$H
   a <- ret.cthmm$a
   tau.true <- ret.cthmm$tau.true
   tau.obs <- ret.cthmm$tau.obs
   z.true <- ret.cthmm$z.true
   z.obs <- ret.cthmm$z.obs
   y.obs <- ret.cthmm$y.obs
   u.obs <- ret.cthmm$u.obs
   pi <- ret.cthmm$pi
   Q <- ret.cthmm$Q
   mu <- ret.cthmm$mu
   eta <- ret.cthmm$eta
   pi.hat.vals <- ret.cthmm$pi.hat.vals
   Q.hat.vals <- ret.cthmm$Q.hat.vals
   mu.hat.vals <- ret.cthmm$mu.hat.vals
   eta.hat.vals <- ret.cthmm$eta.hat.vals
   
}

```


Analyze the CTHMM_Ext1 model:

```{r, echo = TRUE, warning = FALSE}

# run the CT-HMM Ext1 model
if (model.type == "CTHMM_Ext1") {

   ret.cthmm.ext1 <- cthmm.ext1.func(run.algorithm, debugging.mode, latex.table)
   I <- ret.cthmm.ext1$I
   J <- ret.cthmm.ext1$J
   L <- ret.cthmm.ext1$L
   N.vals <- ret.cthmm.ext1$N.vals
   H <- ret.cthmm.ext1$H
   a <- ret.cthmm.ext1$a
   tau.true <- ret.cthmm.ext1$tau.true
   tau.obs <- ret.cthmm.ext1$tau.obs
   z.true <- ret.cthmm.ext1$z.true
   z.obs <- ret.cthmm.ext1$z.obs
   z.acc <- ret.cthmm.ext1$z.acc
   y.obs <- ret.cthmm.ext1$y.obs
   u.obs <- ret.cthmm.ext1$u.obs
   pi <- ret.cthmm.ext1$pi
   Q <- ret.cthmm.ext1$Q
   mu <- ret.cthmm.ext1$mu
   eta <- ret.cthmm.ext1$eta
   pi.hat.vals <- ret.cthmm.ext1$pi.hat.vals
   Q.hat.vals <- ret.cthmm.ext1$Q.hat.vals
   mu.hat.vals <- ret.cthmm.ext1$mu.hat.vals
   eta.hat.vals <- ret.cthmm.ext1$eta.hat.vals
   
}

```


Single-period model with known y;

```{r, echo = TRUE, warning = FALSE}

# log-likelihood
log.likelihood.eval.func <- function(z.in, y.in, u.in, I, J, L, pi.in, mu.in, eta.in) {
  
  N <- length(z)
  ret <- 0
  for (n in 1:N) {
    ret <- ret + log(cthmm.intervention.prob.func(L, eta.in[y.in[n]+1], u.in[n])) + log(cthmm.emission.prob.func(J, mu.in[z.in[n]], y.in[n])) + log(pi.in[z.in[n]])
  }
  return(ret)
}

# set the parameters
I <- 3
J <- 10
L <- 3
pi <- c(0.25, 0.45, 0.30)
mu <- c(0.1, 0.5, 0.9)
eta <- c(0.04, 0.15, 0.26, 0.32, 0.43, 0.51, 0.62, 0.77, 0.81, 0.90)
pi.init <- c(1/3, 1/3, 1/3)
mu.init <- c(0.63, 0.65, 0.68)
eta.init <- c(0.01, 0.03, 0.06, 0.08, 0.45, 0.48, 0.51, 0.55, 0.91, 0.97)

# data generation
N <- 1000
z <- array(numeric(), c(N))
y <- array(numeric(), c(N))
u <- array(numeric(), c(N))
for (n in 1:N) {
  z[n] <- sample(1:I, 1, replace=TRUE, prob=pi)
  y[n] <- rbinom(1, J-1, prob=mu[z[n]])
  u[n] <- rbinom(1, L-1, prob=eta[y[n]+1])
}

# EM algorithm
counter <- 1
pi.tilde <- pi.init
mu.tilde <- mu.init
eta.tilde <- eta.init
while (counter <= 100) {
  
  # E-step
  sufficient.pi <- array(0, c(I))
  sufficient.mu <- array(0, c(I,J))
  sufficient.eta <- array(0, c(J,L))
  for (n in 1:N){
    
    # posterior
    alpha <- array(numeric(), c(I))
    for (i in 1:I) {
      alpha[i] <- cthmm.emission.prob.func(J, mu.tilde[i], y[n]) * pi.tilde[i]
    }
    gamma <- array(numeric(), c(I))
    for (i in 1:I) {
      gamma[i] <- alpha[i] / sum(alpha)
    }
    
    # sufficient
    for (i in 1:I) {
      sufficient.pi[i] <- sufficient.pi[i] + gamma[i]
    }
    for (i in 1:I) {
      for (j in 0:(J-1)) {
        sufficient.mu[i,j+1] <- sufficient.mu[i,j+1] + gamma[i] * sum(y[n]==j)  
      }
    }
    for (j in 0:(J-1)) {
      for (l in 0:(L-1)) {
        sufficient.eta[j+1,l+1] <- sufficient.eta[j+1,l+1] + sum(y[n]==j) * sum(u[n]==l)
      }
    }
    
  }
  
  # M-step
  for (i in 1:I) {
    pi.tilde[i] <- sufficient.pi[i] / sum(sufficient.pi)
  }
  for (i in 1:I) {
    mu.tilde[i] <- sum(c(0:(J-1)) * sufficient.mu[i,]) / ((J-1) * sum(sufficient.mu[i,]))
  }
  for (j in 0:(J-1)) {
    eta.tilde[j+1] <- sum(c(0:(L-1)) * sufficient.eta[j+1,]) / ((L-1) * sum(sufficient.eta[j+1,]))
  }
  
  log.likelihood.vals[counter] <- log.likelihood.eval.func(z, y, u, I, J, L, pi.tilde, mu.tilde, eta.tilde)
  counter <- counter + 1
  
}


```


Single-period model with unknown y:

```{r, echo = TRUE, warning = FALSE}

# log-likelihood
log.likelihood.eval.func <- function(z.in, y.in, u.in, I, J, L, pi.in, mu.in, eta.in) {
  
  N <- length(z)
  ret <- 0
  for (n in 1:N) {
    ret <- ret + log(cthmm.intervention.prob.func(L, eta.in[y.in[n]+1], u.in[n])) + log(cthmm.emission.prob.func(J, mu.in[z.in[n]], y.in[n])) + log(pi.in[z.in[n]])
  }
  return(ret)
}

# set the parameters
I <- 3
J <- 10
L <- 3
pi <- c(0.25, 0.45, 0.30)
mu <- c(0.1, 0.5, 0.9)
eta <- c(0.04, 0.15, 0.26, 0.32, 0.43, 0.51, 0.62, 0.77, 0.81, 0.90)
pi.init <- c(1/3, 1/3, 1/3)
mu.init <- c(0.63, 0.65, 0.68)
eta.init <- c(0.01, 0.03, 0.06, 0.08, 0.45, 0.48, 0.51, 0.55, 0.91, 0.97)

# data generation
N <- 1000
z <- array(numeric(), c(N))
y <- array(numeric(), c(N))
u <- array(numeric(), c(N))
for (n in 1:N) {
  z[n] <- sample(1:I, 1, replace=TRUE, prob=pi)
  y[n] <- rbinom(1, J-1, prob=mu[z[n]])
  u[n] <- rbinom(1, L-1, prob=eta[y[n]+1])
}

# EM algorithm
counter <- 1
max.iterations <- 100
pi.tilde <- pi.init
mu.tilde <- mu.init
eta.tilde <- eta.init
log.likelihood.vals <- array(numeric(), c(max.iterations))
while (counter <= max.iterations) {
  
  # E-step
  sufficient.pi <- array(0, c(I))
  sufficient.mu <- array(0, c(I,J))
  sufficient.eta <- array(0, c(J,L))
  for (n in 1:N){
    
    # posterior
    temp <- array(numeric(), c(I,J))
    for (i in 1:I) {
      for (j in 0:(J-1)) {
        temp[i,j+1] <- cthmm.intervention.prob.func(L, eta.tilde[j+1], u[n]) * cthmm.emission.prob.func(J, mu.tilde[i], j) * pi.tilde[i]
      }
    }
    nu <- array(numeric(), c(I,J))
    for (i in 1:I) {
      for (j in 0:(J-1)) {
        nu[i,j+1] <- temp[i,j+1] / sum(temp)
      }
    }
    gamma <- array(numeric(), c(I))
    for (i in 1:I) {
      gamma[i] <- sum(nu[i,])
    }
    kappa <- array(numeric(), c(J))
    for (j in 0:(J-1)) {
      kappa[j+1] <- sum(nu[,j+1])
    }
    
    # sufficient
    for (i in 1:I) {
      sufficient.pi[i] <- sufficient.pi[i] + gamma[i]
    }
    for (i in 1:I) {
      for (j in 0:(J-1)) {
        sufficient.mu[i,j+1] <- sufficient.mu[i,j+1] + nu[i,j+1]
      }
    }
    for (j in 0:(J-1)) {
      for (l in 0:(L-1)) {
        sufficient.eta[j+1,l+1] <- sufficient.eta[j+1,l+1] + kappa[j+1] * sum(u[n]==l)
      }
    }
    
  }
  
  # M-step
  for (i in 1:I) {
    pi.tilde[i] <- sufficient.pi[i] / sum(sufficient.pi)
  }
  for (i in 1:I) {
    mu.tilde[i] <- sum(c(0:(J-1)) * sufficient.mu[i,]) / ((J-1) * sum(sufficient.mu[i,]))
  }
  for (j in 0:(J-1)) {
    eta.tilde[j+1] <- sum(c(0:(L-1)) * sufficient.eta[j+1,]) / ((L-1) * sum(sufficient.eta[j+1,]))
  }
  

  log.likelihood.vals[counter] <- log.likelihood.eval.func(z, y, u, I, J, L, pi.tilde, mu.tilde, eta.tilde)
  counter <- counter + 1
  
}


```


Single-period model with unknown y and known v:

```{r, echo = TRUE, warning = FALSE}

# log-likelihood
log.likelihood.eval.func <- function(z.in, y.in, u.in, v.in, I, J, L, K, pi.in, mu.in, eta.in, zeta.in) {
  
  N <- length(z)
  ret <- 0
  for (n in 1:N) {
    ret <- ret + log(cthmm.ext1.record.prob.func(K, zeta.in[y.in[n]+1], v.in[n])) + log(cthmm.ext1.intervention.prob.func(L, eta.in[y.in[n]+1], u.in[n])) + log(cthmm.ext1.emission.prob.func(J, mu.in[z.in[n]], y.in[n])) + log(pi.in[z.in[n]])
  }
  return(ret)
}

# set the parameters
I <- 3
J <- 10
L <- 3
K <- 100
pi <- c(0.25, 0.45, 0.30)
mu <- c(0.1, 0.5, 0.9)
eta <- c(0.04, 0.15, 0.26, 0.32, 0.43, 0.51, 0.62, 0.77, 0.81, 0.90)
zeta <- c(0.07, 0.11, 0.19, 0.33, 0.39, 0.55, 0.6, 0.72, 0.84, 0.89)
# eta <- c(0.1, 0.4, 0.8)
# zeta <- c(0.2, 0.3, 0.6)
pi.init <- c(1/3, 1/3, 1/3)
mu.init <- c(0.63, 0.65, 0.68)
eta.init <- c(0.01, 0.03, 0.06, 0.08, 0.45, 0.48, 0.51, 0.55, 0.91, 0.97)
zeta.init <- c(0.01, 0.03, 0.06, 0.08, 0.45, 0.48, 0.51, 0.55, 0.91, 0.97)
# eta.init <- c(0.2, 0.3, 0.4)
# zeta.init <- c(0.6, 0.8, 0.9)

# data generation
N <- 1000
z <- array(numeric(), c(N))
y <- array(numeric(), c(N))
u <- array(numeric(), c(N))
v <- array(numeric(), c(N))
for (n in 1:N) {
  z[n] <- sample(1:I, 1, replace=TRUE, prob=pi)
  y[n] <- rbinom(1, J-1, prob=mu[z[n]])
  u[n] <- rbinom(1, L-1, prob=eta[y[n]+1])
  v[n] <- rbinom(1, K-1, prob=zeta[y[n]+1])
}

print(log.likelihood.eval.func(z, y, u, v, I, J, L, K, pi, mu, eta, zeta))

# EM algorithm
counter <- 1
max.iterations <- 500
pi.tilde <- pi.init
mu.tilde <- mu.init
eta.tilde <- eta.init
zeta.tilde <- zeta.init
log.likelihood.vals <- array(numeric(), c(max.iterations))
while (counter <= max.iterations) {
  
  # E-step
  sufficient.pi <- array(0, c(I))
  sufficient.mu <- array(0, c(I,J))
  sufficient.eta <- array(0, c(J,L))
  sufficient.zeta <- array(0, c(J,K))
  for (n in 1:N){
    
    # posterior
    temp <- array(numeric(), c(I,J))
    for (i in 1:I) {
      for (j in 0:(J-1)) {
        temp[i,j+1] <- cthmm.ext1.record.prob.func(K, zeta.tilde[j+1], v[n]) * cthmm.ext1.intervention.prob.func(L, eta.tilde[j+1], u[n]) * cthmm.ext1.emission.prob.func(J, mu.tilde[i], j) * pi.tilde[i]
      }
    }
    nu <- array(numeric(), c(I,J))
    for (i in 1:I) {
      for (j in 0:(J-1)) {
        nu[i,j+1] <- temp[i,j+1] / sum(temp)
      }
    }
    gamma <- array(numeric(), c(I))
    for (i in 1:I) {
      gamma[i] <- sum(nu[i,])
    }
    kappa <- array(numeric(), c(J))
    for (j in 0:(J-1)) {
      kappa[j+1] <- sum(nu[,j+1])
    }
    
    # sufficient
    for (i in 1:I) {
      sufficient.pi[i] <- sufficient.pi[i] + gamma[i]
    }
    for (i in 1:I) {
      for (j in 0:(J-1)) {
        sufficient.mu[i,j+1] <- sufficient.mu[i,j+1] + nu[i,j+1]
      }
    }
    for (j in 0:(J-1)) {
      for (l in 0:(L-1)) {
        sufficient.eta[j+1,l+1] <- sufficient.eta[j+1,l+1] + kappa[j+1] * sum(u[n]==l)
      }
    }
    for (j in 0:(J-1)) {
      for (k in 0:(K-1)) {
        sufficient.zeta[j+1,k+1] <- sufficient.zeta[j+1,k+1] + kappa[j+1] * sum(v[n]==k)
      }
    }
    
  }
  
  # M-step
  for (i in 1:I) {
    pi.tilde[i] <- sufficient.pi[i] / sum(sufficient.pi)
  }
  for (i in 1:I) {
    mu.tilde[i] <- sum(c(0:(J-1)) * sufficient.mu[i,]) / ((J-1) * sum(sufficient.mu[i,]))
  }
  for (j in 0:(J-1)) {
    eta.tilde[j+1] <- sum(c(0:(L-1)) * sufficient.eta[j+1,]) / ((L-1) * sum(sufficient.eta[j+1,]))
  }
  for (j in 0:(J-1)) {
    zeta.tilde[j+1] <- sum(c(0:(K-1)) * sufficient.zeta[j+1,]) / ((K-1) * sum(sufficient.zeta[j+1,]))
  }
  

  log.likelihood.vals[counter] <- log.likelihood.eval.func(z, y, u, v, I, J, L, K, pi.tilde, mu.tilde, eta.tilde, zeta.tilde)
  counter <- counter + 1
  
  print(counter-1)
  print(pi.tilde)
  print(log.likelihood.vals[counter-1])
}


```



```{r, echo = TRUE, warning = FALSE}

# record model
cthmm.ext1.record.prob.func <- function(K, zeta.in, k.in) {
  
  ret <- choose(K-1, k.in) * (zeta.in ^ k.in) * ((1-zeta.in) ^ (K-1 - k.in))
  
  return(ret)
  
}

```
